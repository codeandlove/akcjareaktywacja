import React, { Component } from "react";import PropTypes from "prop-types";import { EditorState, convertToRaw, ContentState } from "draft-js";import { Editor } from "react-draft-wysiwyg";import draftToHtml from "draftjs-to-html";import htmlToDraft from 'html-to-draftjs';import "./EventForm.scss";import truncate from "truncate";import UrlSlug from "url-slug";import ReCAPTCHA from "react-google-recaptcha";import { connect } from "react-redux";import { compose } from "redux";import { firebaseConnect, isEmpty, isLoaded } from "react-redux-firebase";import moment from "moment";import "moment/locale/pl";import DatePicker from "react-datepicker";import {Container, Segment, Header, Message, Button, Form, Input, Icon, Confirm} from "semantic-ui-react";import {ACTION, PREVIEW} from "../../routers/routers";import {analytics} from "../../../firebase";class EventForm extends Component {    constructor(props) {        super(props);        this.state = {            title: null,            editorState: null,            description: null,            short: null,            date: moment().valueOf(),            owner: null,            contact: null,            coordinates: null,            coordinatesEdit: false,            openAddConfirm: false,            openCancelConfirm: false,            location: null,            discard: false,            messageType: null,            captcha: false        }    }    componentDidMount() {        const { coordinates, profile, params, toggleColumn } = this.props;        const draft = JSON.parse(localStorage.getItem("eventDraft"));        analytics.logEvent('User opened a event form')        toggleColumn(true);        this.setState({            editorState: EditorState.createEmpty()        });        if(coordinates) {            this.setState({                coordinates: coordinates            });        }        if(!isEmpty(profile)) {            this.setState({                owner: profile.displayNick || ""            });        }        if(!isEmpty(params)) {            let date = moment(params.eventDate, "DD-MM-YYYY").hour(20);            //Prevent to set past date            if(date.diff(moment(), "days") < 0) {                date = moment();            }            this.setState({                date: date            });        }        if(!isEmpty(draft)) {            //read from local storage            let draftState = {                title: draft.title,                location: draft.location,                contact: draft.contact,                description: draft.description,                short: draft.short            };            if(draft.date && !isEmpty(params)) {                draftState = {                    ...draftState,                    date: moment(draft.date).valueOf()                }            }            if(draft.coordinates && !coordinates) {                draftState = {                    ...draftState,                    coordinates: draft.coordinates                }            }            if(!this.state.owner) {                draftState = {                    ...draftState,                    owner: draft.owner                }            }            if(draft.description) {                const contentBlock = htmlToDraft(draft.description);                const contentState = ContentState.createFromBlockArray(contentBlock.contentBlocks);                this.setState({                    editorState: EditorState.createWithContent(contentState)                });            }            this.setState({                ...draftState,                messageType: "editor/draft-state"            }, () => {                this.props.updateEvent({                    coordinates: draft.coordinates ? draft.coordinates : coordinates                })            });        }        window.addEventListener('beforeunload', this.setDraft);    }    componentWillUnmount() {        const { discard, coordinatesEdit } = this.state;        window.removeEventListener('beforeunload', this.setDraft);        if(discard) {            localStorage.removeItem("eventDraft");            return        }        if(coordinatesEdit) {            this.setDraft({                coordinates: null            });            return;        }        this.setDraft();    }    componentWillReceiveProps(props) {        if(!!props.coordinates) {            this.setState({                coordinates: props.coordinates            });        }        if(!isEmpty(props.profile)) {            this.setState({                owner: props.profile.displayNick || ""            });        }    }    setDraft = (custom) => {        const draft = {            ...this.state,            date: this.state.date,            ...custom        };        localStorage.setItem("eventDraft", JSON.stringify(draft));    }    initAddConfirm = () => {        this.setState({            openAddConfirm: true        });    };    executeAddConfirmation = (val) => {        this.setState({            openAddConfirm: false        }, () => val && this.handleSave());    }    executeCancelConfirmation = (val) => {        this.setState({            openCancelConfirm: false        }, () => val && this.cancelForm());    }    renderMessage = () => {        const { messageType } = this.state;        let result = null;        switch(messageType) {            case "nick/nick-exist":                result = (                    <Message                        error                        header="Błąd formularza"                        size="mini"                        content="Użytkownik o takim nicku już istnieje. Jeśli to Ty, zaloguj się aby korzystać z Twojego podpisu."                    />                );                break;            case "editor/draft-state":                result = (                    <Message                        color="green"                        size="mini"                        content="Zapisano wersję roboczą wydarzenia."                    />                );                break;            default:                result = null;                break;        }        return (result) ? result : null;    };    validateValues = (values) => {        const result = values.filter(val => {            return this.state[val] === false || this.state[val] === null || !this.state[val];        });        return result.length !== 0;    };    handleChange = name => event => {        switch(name) {            case "date":                this.setState({                    date: event                });                break;            default:                this.setState({                    [name]: event.target.value                });        }    };    getLocation = coordinates => {        const latLng = `${coordinates.lat}, ${coordinates.lng}`;        this.setState({            location: latLng        })    };    onEditorStateChange = (editorState) => {        this.setState({            editorState,            description: draftToHtml(convertToRaw(editorState.getCurrentContent())),            short: truncate(editorState.getCurrentContent().getPlainText(), 100)        });    };    handleSave = () => {        const { title, description, short, date, owner, contact, coordinates, location } = this.state;        const { auth, firebase, client: {ip, duuid} } = this.props;        const data = {            title: title,            description: description,            short: short,            owner: owner,            contact: contact,            coordinates: coordinates,            location: location,            date: date.valueOf(),            slug: UrlSlug(`${title} ${moment().format("L")}`)        };        if(this.validateValues(["title", "description", "date", "owner", "contact", "coordinates", "captcha"])) return;        if(isLoaded(auth) && isEmpty(auth)){            const usersRef = firebase.database().ref("/users");            //Check if nick is unique            usersRef.orderByChild("displayNick").equalTo(owner).once("value").then(snapshot => {                if(!snapshot.val()) {                    firebase.auth().signInAnonymously().then(res => {                        this.props.saveEvent({                            ...data,                            participants: [res.user.uid],                            clients_ip: [`${ip}.${duuid}`]                        });                        this.setState({                            discard: true                        })                    });                } else {                    this.setState({                        messageType: "nick/nick-exist"                    });                }            });        } else {            this.props.saveEvent({                ...data,                participants: [auth.uid],                clients_ip: [`${ip}.${duuid}`]            });            this.setState({                discard: true            })        }    }    captchaVerifyHandler = () => {        this.setState({            captcha: true        })    }    confirmCancelForm = () => {        this.setState({            openCancelConfirm: true        })    }    cancelForm = () => {        this.setState({            discard: true        }, () => {            this.props.cancel();        })    }    previewDraft = () => {        const { router } = this.context;        this.setDraft();        router.history.push(`/${ACTION}/${PREVIEW}`);    }    handleKeyPress = event => {        if(event.key === 'Enter') {            event.preventDefault();        }    }    formatCoordinates = () => {        const {coordinates} = this.state;        if(!coordinates) return null;        return `${coordinates.lat}, ${coordinates.lng}`;    }    changeCoordinates = () => {        this.setState({            coordinatesEdit: true        });        this.props.toggleColumn(false);    }    render() {        const { title, location, coordinates, owner, date, contact, editorState, openAddConfirm, openCancelConfirm, messageType } = this.state;        const { profile, isColExpanded } = this.props;        return (            <Container>                <Segment clearing basic>                    <Button basic onClick={this.confirmCancelForm} floated="right" icon="x" />                    {                        isColExpanded ? (                            <Button className="button-event-form-compress" basic onClick={this.props.toggleColExpand} floated="right" icon="compress" />                        ) : (                            <Button className="button-event-form-expand" basic onClick={this.props.toggleColExpand} floated="right" icon="expand" />                        )                    }                    <Header floated="left" size="large">                        Dodaj wydarzenie                    </Header>                </Segment>                <Segment clearing basic>                    <Form error={messageType !== null} onSubmit={this.initAddConfirm} onKeyPress={this.handleKeyPress}>                        {this.renderMessage()}                        <Form.Field>                            <label>Tytuł</label>                            <Input placeholder="Wpisz tytuł wydarzenia" type="text" id="title" name="title" value={title || ""} onChange={this.handleChange("title")} />                        </Form.Field>                        <Form.Group widths="equal">                            {isEmpty(profile) ?                                (                                    <Form.Field width={6}>                                        <label>Organizator</label>                                        <Input ref={el => this.nick = el} id="owner" name="owner" value={owner} placeholder="Wpis nazwę organizatora" onChange={this.handleChange("owner")} />                                    </Form.Field>                                ) : (                                    <Form.Field width={6}>                                        <label>Organizator</label>                                        <Input icon='user' iconPosition='left' value={owner} name="owner" disabled/>                                    </Form.Field>                                )                            }                            <Form.Input width={6} label="Kontakt" id="contact" name="contact" value={contact} placeholder="Jak się z Tobą skontaktować?" onChange={this.handleChange("contact")} />                        </Form.Group>                        <Form.Group widths="equal">                            <Form.Field width={6}>                                <label>Data i czas</label>                                <DatePicker                                    customInput={<DateInput />}                                    selected={moment(date)}                                    onChange={this.handleChange("date")}                                    onSelect={this.handleChange("date")}                                    minDate={moment()}                                    minTime={moment(date).startOf('day') <= moment().startOf('day') ? moment().add(15, "minutes") : moment().startOf('day')}                                    maxTime={moment().endOf('day')}                                    showTimeSelect                                    timeFormat="HH:mm"                                    timeIntervals={15}                                    dateFormat="LLL"                                    locale="pl"                                    timeCaption="Godzina"                                />                            </Form.Field>                            <Form.Field width={6}>                                <label>Miejsce spotkania</label>                                <Input placeholder="Wpisz lokację" type="text" id="location" name="location" value={location || ""} onChange={this.handleChange("location")} />                            </Form.Field>                        </Form.Group>                        <Form.Field>                            <label>Koordynaty</label>                            {                                !coordinates && (                                    <Message                                        color="orange"                                        size="mini"                                        content="Klinknij na mapę aby dodać punkt w miejscu spotkania."                                    />                                )                            }                            <Input                                action={{                                    color: 'olive',                                    labelPosition: 'right',                                    icon: 'map marker alternate',                                    content: !coordinates ? 'Wybierz' : 'Zmień',                                    type: 'button',                                    onClick: () => this.changeCoordinates()                                }}                                value={this.formatCoordinates()}                                readOnly                            />                        </Form.Field>                        <Form.Field>                            <label>Opis</label>                            <Editor                                editorState={editorState}                                wrapperClassName="ar-editor-wrapper"                                editorClassName="ar-editor"                                onEditorStateChange={this.onEditorStateChange}                                localization={{                                    locale: "pl",                                }}                                toolbar={{                                    options: ["inline", "fontSize", "textAlign", "colorPicker", "link", "emoji", "image"],                                    inline: {                                        options: ["bold"],                                    },                                    textAlign: {                                        inDropdown: true                                    },                                    link: {                                        popupClassName: 'dropdown-custom-center'                                    },                                    emoji: {                                        popupClassName: 'dropdown-custom-right'                                    },                                    image: {                                        popupClassName: 'dropdown-custom-right'                                    }                                }}                            />                        </Form.Field>                        <Form.Field>                            <ReCAPTCHA                                ref="recaptcha"                                sitekey={process.env.REACT_APP_RECAPTCHA_API_V2}                                onChange={this.captchaVerifyHandler}                            />                        </Form.Field>                        <Form.Field>                            <Button type="button" onClick={this.confirmCancelForm} floated="left">                                Anuluj                            </Button>                            <Button type="submit" floated="right" color="olive" disabled={this.validateValues(["title", "description", "date", "owner", "contact", "coordinates", "captcha"]) || messageType === "nick/nick-exist"}>                                <Icon name="check" />                                Dodaj                            </Button>                            <Button type="button" onClick={this.previewDraft} floated="right" color="blue">                                Podgląd                            </Button>                        </Form.Field>                    </Form>                    <Confirm                        open={openAddConfirm}                        cancelButton="Nie"                        confirmButton="Tak"                        content="Czy chcesz dodać nowe wydarzenie w zaznaczonym miejscu?"                        onCancel={() => this.executeAddConfirmation(false)}                        onConfirm={() => this.executeAddConfirmation(true)}                    />                    <Confirm                        open={openCancelConfirm}                        cancelButton="Nie"                        confirmButton="Tak"                        content="Czy chcesz zrezygnować z dodawania tego wydarzenia? Wszystkie dane z formularza zostaną trwale usunięte."                        onCancel={() => this.executeCancelConfirmation(false)}                        onConfirm={() => this.executeCancelConfirmation(true)}                    />                </Segment>            </Container>        )    }}class DateInput extends Component {    render () {        return (            <Input placeholder="Podaj datę i czas" type="text" id="date" name="date" value={this.props.value} onClick={this.props.onClick} onFocus={this.props.onClick} />        )    }}EventForm.contextTypes = {    router: PropTypes.object};const mapStateToProps = state => {    return {        client: state.client,        ...state.map    }};export default compose(    firebaseConnect(),    connect(({ firebase: { auth, profile } }) => ({ auth, profile })),    connect(mapStateToProps))(EventForm);